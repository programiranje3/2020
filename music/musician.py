"""Domain classes and functions related to the concept of musician
"""


# from util import utility
from music.enums import Vocals, Instrument
import json


class Musician:
    """The class describing the concept of musician.
    It is assumed that a musician is sufficiently described by their
    name and whether they are a solo musician or a member of a band.

    This class illustrates some of the important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - __dict__ attribute of all objects ()
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, name, is_band_member=True):
        self.name = name
        self.is_band_member = is_band_member
        # self.m = 23
        # self.__n = 'lll'                                    # 'private' field

    # Properties: 'private' fields; run setters and getters in the debugger.
    # Make name a property (after setting up __init__(), __str__(), __eq__(), methods,...).
    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name

    # Add an immutable property (no setter for it)
    @property
    def complete_info(self):
        return self

    def __str__(self):
        return self.name + ', ' + ('band member' if self.is_band_member else 'solo musician')

    def __eq__(self, other):
        return isinstance(other, Musician) and other.name == self.name and other.is_band_member == self.is_band_member

    def play(self, song_title, *args, **kwargs):
        """Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, rhythm counts, expressions of gratitude and messages. A call example:
            <musician>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        # print(self.name + ' plays:', song_title)
        rhythm_count = kwargs['rhythm_count'] if 'rhythm_count' in kwargs.keys() else ''
        messages = ' '.join([v for k, v in kwargs.items() if not k == 'rhythm_count']) if kwargs else ''
        return f'{self.name} playing: {rhythm_count}! - {song_title} - {" ".join(arg for arg in args)} {messages}'

    def play_song(self, song_title, *args, **kwargs):
        """Demonstrates calling another method from the same class (self.<method>(...) as a mandatory syntax).
        """

        return self.play(song_title, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, musician_string):
        """Inverted __str__() method.
        Assumes that musician_string is in the format generated by __str__().
        """

        name, band_member = musician_string.split(', ')
        return cls(name, (True if band_member.startswith('band') else False))


class MusicianEncoder(json.JSONEncoder):
    """JSON encoder for Musician objects (cls= parameter in json.dumps()).
    """

    def default(self, musician):
        # recommendation: always use double quotes with JSON

        # can simply return musician_py_to_json(musician), to avoid code duplication
        return musician_py_to_json(musician)


def musician_py_to_json(musician):
    """JSON encoder for Musician objects (default= parameter in json.dumps()).
    """

    # recommendation: always use double quotes with JSON

    if isinstance(musician, Musician):
        d = musician.__dict__.copy()
        return {"__Musician__": d}
    else:
        raise TypeError(f'object of type {musician.__class__.__name__}')


def musician_json_to_py(musician_json):
    """JSON decoder for Musician objects (object_hook= parameter in json.loads()).
    """

    if "__Musician__" in musician_json:
        m = Musician('')
        m.__dict__.update(musician_json["__Musician__"])
        return m
    return musician_json


class Singer(Musician):
    """The class describing the concept of singer.
    It is assumed that a singer is sufficiently described as a Musician,
    with the addition of whether they are a lead or a background singer.

    Useful link (related to inheritance in Python):
    https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs/3394902#3394902 (calling super() in constructors)
    """

    # Version 1 - no multiple inheritance
    # def __init__(self, name, vocals, is_band_member=True):
    #     super().__init__(name, is_band_member)
    #     # self.name = name
    #     # self.is_band_member = is_band_member
    #     self.vocals = vocals if isinstance(vocals, Vocals) else None

    # Version 2 - with multiple inheritance
    def __init__(self, vocals, **kwargs):
        super().__init__(**kwargs)
        self.vocals = vocals if isinstance(vocals, Vocals) else None

    def __str__(self):
        return super().__str__() + '; ' + self.vocals.name.lower().replace('_', ' ')

    def __eq__(self, other):
        return isinstance(other, Singer) and super().__eq__(other) and self.vocals == other.vocals

    def play(self, song_title, *args, **kwargs):
        """Overrides the play() method from superclass.
        Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, expressions of gratitude and messages. A call example:
            <singer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        return super().play(song_title, *args, **kwargs) + '\nYeah!'


class Songwriter(Musician):
    """The class describing the concept of songwriter.
    It is assumed that a songwriter is sufficiently described as a musician
    who writes songs and plays an instrument.
    """

    # Version 1 - no multiple inheritance
    # def __init__(self, name, instrument, is_band_member=True):
    #     super().__init__(name, is_band_member)
    #     self.instrument = instrument if isinstance(instrument, Instrument) else None
    #     self.writes_songs = True

    # Version 2 - with multiple inheritance
    def __init__(self, instrument, **kwargs):
        super().__init__(**kwargs)
        self.instrument = instrument if isinstance(instrument, Instrument) else None
        self.writes_songs = True

    def __str__(self):
        return super().__str__() + '; ' + self.instrument.name.lower().replace('_', ' ')

    def what_do_you_do(self):
        """Just a simple method to describe the concept of songwriter.
        """

        s = f'I am {self.name}. I write songs.' if self.writes_songs else f'I am {self.name}'
        print(s)


class SingerSongwriter(Songwriter, Singer, ):
    """The class describing the concept of singer-songwriter.
    It is assumed that a singer-songwriter is sufficiently described as a Singer who is simultaneously a Songwriter.

    Useful links :
    https://stackoverflow.com/a/50465583/1899061 (designing classes (i.e. their __init__() methods) for multiple inh.)
    https://stackoverflow.com/a/533675/1899061 (mixins explained, and what good they are in multiple inheritance)
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def __str__(self):
        return 'Singer-songwriter: ' + super().__str__()


if __name__ == "__main__":

    # # from testdata.musicians import *
    # johnLennon = Musician('John Lennon', is_band_member=True)

    # # Print objects
    # john = Musician('John Lennon', is_band_member=True)
    # print(john.name)
    # # john.name = 'Lennon'
    # print(john)
    # print()

    # # Compare objects
    # print(john == johnLennon)
    # print(john.__eq__(johnLennon))
    # print(john.__ne__(johnLennon))
    # print()

    # Access data fields (instance variables), including 'private' fields
    # print(johnLennon.m)
    # print(johnLennon.__n)
    # print(johnLennon._Musician__n)
    # print()

    # # Add new data fields (instance variables)
    # # johnLennon.city = 'Liverpool'
    # # print(johnLennon.city)
    # johnLennon.__setattr__('city', 'Liverpool')
    # print(johnLennon.__getattribute__('city'))
    # #   1. <object>.<new_attr> = <value>
    # #   2. <object>.__setattr__('<new_attr>', <value>)      # counterpart: <object>.__getattribute__('<attr>')
    # #   3. setattr(<object>, '<new_attr>', <value>))        # counterpart: getattr(<object>, '<attr>')
    # print()

    # # Calling methods
    # # john.play('Nobody Told Me')
    # # john.play_song('Nobody Told Me')
    # print(johnLennon.play('I Saw Her Standing There', 'Thank you!',
    #                       rhythm_count='One, two, three, four',
    #                       end='Good night!'))
    # print(johnLennon.play_song('I Saw Her Standing There', 'Thank you!',
    #                            rhythm_count='One, two, three, four',
    #                            end='Good night!'))
    # print()

    # Demonstrate object data fields and methods in Python Console for some built-in classes (boolean, int, object,...)
    # - True + 1
    # - True.__int__()
    # - (1).__class__.__name__
    # - (1).__class__
    # - o.__dir__()
    # - o.__dir__
    # - o.__dict__

    # # Demonstrate object data fields and methods for Musician objects
    # print(johnLennon.__dict__)
    # print(johnLennon.complete_info)
    # print()

    # # Demonstrate @classmethod (from_str())
    # print(Musician.from_str(str(johnLennon)))
    # print()

    # # Demonstrate inheritance
    # # object class (like the Object class in Java; all classes inherit from object
    # #   try, e.g., list.__mro__ in the console)
    # #   object class defines object.__eq__(self, other) etc.
    # #   object.__ne__(self, other), the inverse of object.__eq__(self, other),
    # #   is provided by Python automatically once object.__eq__(self, other) is implemented
    # jL = Singer(name='John Lennon', vocals=Vocals.LEAD_VOCALS, is_band_member=True)
    # print(jL)
    # johnL = Songwriter(name="John Lennon", instrument=Instrument.RHYTHM_GUITAR)
    # print(johnL)
    # johnL.what_do_you_do()
    # print()

    # # Demonstrate method overriding
    # print(jL.play('I Saw Her Standing There', 'Thank you!',
    #                       rhythm_count='One, two, three, four',
    #                       end='Good night!'))
    # print()

    # # Demonstrate multiple inheritance and MRO.
    # # Make sure to read this first: https://stackoverflow.com/a/50465583/1899061 (especially Scenario 3).
    # lennon = SingerSongwriter(name='John Lennon',
    #                           vocals=Vocals.LEAD_VOCALS,
    #                           instrument=Instrument.RHYTHM_GUITAR,
    #                           is_band_member=True)
    # print(lennon)
    # print(SingerSongwriter.__mro__)
    # print()

    # # Demonstrate JSON encoding/decoding of Performer objects
    # # Single object
    # johnLennon = Musician('John Lennon', is_band_member=True)
    # johnLennon_json = json.dumps(johnLennon, default=musician_py_to_json, indent=4)
    # # johnLennon_json = json.dumps(johnLennon, cls=MusicianEncoder, indent=4)
    # # from datetime import date
    # # johnLennon_json = json.dumps(date.today(), cls=MusicianEncoder, indent=4)
    # print(johnLennon_json)
    # print()
    # johnLennon_py = json.loads(johnLennon_json, object_hook=musician_json_to_py)
    # print(johnLennon_py)
    # print(johnLennon_py == johnLennon)

    # # List of objects
    johnLennon = Musician('John Lennon', is_band_member=True)
    # paulMcCartney = Musician('Paul McCartney', is_band_member=True)
    # georgeHarrison = Musician('George Harrison', is_band_member=True)
    # ringoStarr = Musician('Ringo Starr', is_band_member=True)
    # the_beatles = (johnLennon, paulMcCartney, georgeHarrison, ringoStarr)
    #
    # the_beatles_json = json.dumps(the_beatles, default=musician_py_to_json, indent=4)
    # print(the_beatles_json)

    # print(johnLennon.__dict__)
    # print(vars(johnLennon))